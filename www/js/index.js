function t(...h){const M=[];for(let $ of h){const q=document.getElementById($);if(q===null)return console.error(`Cannot get any HTML Element given the "${$}" id`),null;M.push(q)}return M}function b(h){const M=t(h.canvasId,h.solutionSpaceSizePId,h.resetBtnId,h.gtBtnId,h.btBtnId,h.ncCheckboxId,h.acNoneRadioId,h.ac1RadioId,h.ac3RadioId,h.testedSolutionsPId,h.prunedSolutionsPId,h.progressPId,h.timeleftPId);if(M===null)return null;return{canvas:M[0],solutionSpaceSizeP:M[1],resetBtn:M[2],gtBtn:M[3],btBtn:M[4],ncCheckbox:M[5],acNoneRadio:M[6],ac1Radio:M[7],ac3Radio:M[8],testedSolutionsP:M[9],prunedSolutionsP:M[10],progressP:M[11],timeleftP:M[12]}}function S(h){h.elements.canvas.onmousemove=(M)=>{M.stopPropagation();const{offsetX:$,offsetY:q}=M,L=Math.min(Math.floor($/h.ui.cellSize),8),Q=Math.min(Math.floor(q/h.ui.cellSize),8),W=h.getSelectedCell();if(W===null||W[0]!==L||W[1]!==Q)h.setSelectedCell([L,Q]),h.refreshGrid()},h.elements.canvas.onmouseout=(M)=>{if(M.stopPropagation(),h.getSelectedCell()!==null)h.setSelectedCell(null),h.refreshGrid()},document.onkeyup=(M)=>{if(M.stopPropagation(),M.key>="1"&&M.key<="9"&&h.getSelectedCell()!==null){const $=parseInt(M.key);if($%1===0)h.toggle($)}},h.elements.resetBtn.onclick=(M)=>{h.app.reset()},h.elements.gtBtn.onclick=(M)=>{h.app.reset(),h.app.launchGTSolve()}}function C(h){h.canvas.onmousemove=null,h.canvas.onmouseout=null,document.onkeyup=null}class X{h;M;static _uis=new WeakMap;static bgColor="#DDD";static thinLineColor="#AAA";static boldLineColor="#000";static impactedColor="#eec";static selectedColor="#ff6";static get(h){if(X._uis.has(h))return X._uis.get(h);const M=h.getContext("2d");if(M===null)return!1;const $=new X(h,M);return X._uis.set(h,$),$}_cellSize;constructor(h,M){this._canvas=h;this._ctx=M;this._cellSize=Math.round(Math.min(h.width,h.height)/9)}get width(){return this._canvas.width}get height(){return this._canvas.height}get cellSize(){return this._cellSize}clearCanvas(){return this._ctx.fillStyle=X.bgColor,this._ctx.fillRect(0,0,this.width,this.height),this}drawCell(h,M,$=this._cellSize,q=X.thinLineColor,L){const Q=h*$,W=M*$;if(L)this._ctx.fillStyle=L,this._ctx.fillRect(Q+1,W+1,$-2,$-2);return this._ctx.strokeStyle=q,this._ctx.strokeRect(Q,W,$,$),this}drawRow(h,M){for(let $=0;$<9;$++)this.drawCell($,h,this._cellSize,X.thinLineColor,M);return this}drawColumn(h,M){for(let $=0;$<9;$++)this.drawCell(h,$,this._cellSize,X.thinLineColor,M);return this}drawGroup(h,M,$){this.drawCell(h,M,this._cellSize*3,X.boldLineColor,$);for(let q=0;q<3;q++)for(let L=0;L<3;L++)this.drawCell(h*3+L,M*3+q,this._cellSize,X.thinLineColor);return this}drawCellValue(h,M,$){this._ctx.fillStyle="#000",this._ctx.font="bold 60px Arial",this._ctx.textBaseline="middle",this._ctx.textAlign="center";const q=h*this._cellSize+Math.floor(this._cellSize*0.5),L=M*this._cellSize+Math.floor(this._cellSize*0.575);return this._ctx.fillText($.toString(),q,L),this}drawCellDomain(h,M,$){this._ctx.fillStyle="#000",this._ctx.font="16px Arial",this._ctx.textBaseline="top",this._ctx.textAlign="start";const q=Math.max(this._cellSize-2,Math.floor(this._cellSize*0.8)),L=Math.floor(q/3),Q=Math.max(1,Math.floor(this._cellSize*0.1)),W=h*this._cellSize+Q,Y=M*this._cellSize+Q;for(let Z=1;Z<=9;Z++){const T=$.has(Z)?Z:null,A=(Z-1)%3,g=Math.floor((Z-1)/3),x=W+L*A,k=Y+L*g;this._ctx.fillText(T!==null?T.toString():"",x,k)}return this}drawEmptyGrid(){this.clearCanvas();for(let h=0;h<3;h++)for(let M=0;M<3;M++)this.drawGroup(M,h);return this}colorizeSelectedStuff(h){if(h===null)return this;const M=[Math.floor(h[0]/3),Math.floor(h[1]/3)];return this.drawRow(h[1],X.impactedColor).drawColumn(h[0],X.impactedColor).drawGroup(M[0],M[1],X.impactedColor).drawCell(h[0],h[1],this._cellSize,X.thinLineColor,X.selectedColor),this}}function B(){const h=new WebSocket(`ws://${location.host}`);h.onopen=()=>setInterval(()=>h.send("ping"),5000),h.onmessage=(M)=>{if(M.data!=="Well received")console.log(M.data);if(M.data==="reload")location.reload()}}class _{h;M;$;q;L;Q;constructor(h,M,$,q,L,Q){this._app=h;this._solutionSpaceSizeP=M;this._testedSolutionsP=$;this._prunedSolutionsP=q;this._progressP=L;this._timeleftP=Q}display(){const h=this._app.solutionSpaceSize;if(typeof h==="undefined")return;this._solutionSpaceSizeP.innerText=`${h} solutions possibles.`;const{start:M,tested:$,pruned:q}=this._app.stats;this._testedSolutionsP.innerText=`${$} solutions test\xE9es.`,this._prunedSolutionsP.innerText=`${q} solutions \xE9lagu\xE9es.`}static create(h){return new _(h.app,h.solutionSpaceSizeP,h.testedSolutionsP,h.prunedSolutionsP,h.progressP,h.timeleftP)}}function E(h,M){return O.fromJSON(h,M)}function c(h){return O.getByName(h)}class O{static domains=new Map;_values;constructor(h=[]){this._values=new Set(h)}add(h){this._values.add(h)}del(h){this._values.delete(h)}has(h){return this._values.has(h)}copy(h){const M=new O(this.toJSON());return O.domains.set(h,M),M}toJSON(){const h=[];for(let M of this._values)h.push(M);return h}getSize(){return this._values.size}static validateJSON(h){if(Array.isArray(h)&&h.length>0){const M=typeof h[0];if(!h.reduce((q,L)=>q&&typeof L===M,!0))return!1}return!0}static fromJSON(h,M){if(O.validateJSON(M)){const $=new O(M);return O.domains.set(h,$),$}throw new Error("At least one element do not have the same type as the other")}static getByName(h){return O.domains.get(h)}}function P(h,M){return V.fromJSON(h,M)}function F(h){return V.getByName(h)}class V{h;M;$;static variables=new Map;_value;constructor(h,M,$){this._name=h;this._domainName=M;this._domain=$}get name(){return this._name}get domain(){return this._domain}get value(){return this._value}set(h){if(this._domain.has(h))this._value=h}unset(){this._value=void 0}isSet(){return typeof this._value!=="undefined"}toJSON(){const h={domain:this._domainName};if(this.isSet())h.value=this._value;return h}static fromJSON(h,M){const $=c(M.domain);if(typeof $==="undefined")throw new Error(`The variable "${h}" reference an unknown domain "${M.domain}"`);const q=new V(h,M.domain,$.copy(`${h}-domain`));return V.variables.set(h,q),q}static getByName(h){return V.variables.get(h)}}class H{h;static constraints=new Map;constructor(h){this._name=h}get name(){return this._name}static getByName(h){return H.constraints.get(h)}}class G extends H{M;$;static type="intension";static arity=1;constructor(h,M,$){super(h);this._v=M;this._checkConsistency=$}get type(){return G.type}get arity(){return G.arity}get variableName(){return this._v.name}checkConsistency(){return this._v.isSet()&&this._checkConsistency(this._v.value)}toJSON(){return{type:G.type,arity:G.arity,variable:this._v.name,valueConsistency:this._checkConsistency.toString()}}static create(h,M){const $=F(M.variable);if(!$)throw new Error(`The constraint "${h}" refer to an unknown variable "${M.variable}"`);const q=new G(h,$,M.valueConsistency);return H.constraints.set(h,q),q}static fromJSON(h,M){const $=new Function(`return ${M.valueConsistency}`)(),q={...M,valueConsistency:$};return G.create(h,q)}}class J extends H{M;static type="extension";static arity=1;_index;_areSupports;_areConflicts;constructor(h,M,$,q){super(h);this._v=M;this._index=new Set($.filter((L)=>M.domain.has(L))),this._areSupports=q==="supports",this._areConflicts=q==="conflicts"}get type(){return J.type}get arity(){return J.arity}get variableName(){return this._v.name}checkConsistency(){if(!this._v.isSet())return!1;return this._index.has(this._v.value)?this._areSupports:this._areConflicts}toJSON(){const h=[];for(let M of this._index.values())h.push(M);return{type:J.type,arity:J.arity,variable:this._v.name,values:h,valuesType:this._areSupports?"supports":"conflicts"}}static create(h,M){const $=F(M.variable);if(!$)throw new Error(`The constraint "${h}" refer to an unknown variable "${M.variable}"`);const q=new J(h,$,M.values,M.valuesType);return H.constraints.set(h,q),q}static fromJSON(h,M){return J.create(h,M)}}function o(h){return h.type===G.type}function s(h){return h.type===G.type}function d(h,M){return o(M)?G.fromJSON(h,M):J.fromJSON(h,M)}function j(h,M){return s(M)?G.create(h,M):J.create(h,M)}var N=1;class w extends H{M;$;static type="intension";static arity=2;constructor(h,M,$){super(h);this._v=M;this._checkConsistency=$}get type(){return w.type}get arity(){return w.arity}get variableNames(){return[this._v[0].name,this._v[1].name]}checkConsistency(){const[h,M]=this._v;return h.isSet()&&M.isSet()&&this._checkConsistency(h.value,M.value)}toJSON(){return{type:w.type,arity:w.arity,variables:this.variableNames,valuesConsistency:this._checkConsistency.toString()}}static create(h,M){const[$,q]=M.variables,L=F($),Q=F(q);if(!(L&&Q))throw new Error(`The constraint "${h}" refers to the variables "${$}" and "${q}" but one of them is unknown`);const W=new w(h,[L,Q],M.valuesConsistency);return H.constraints.set(h,W),W}static fromJSON(h,M){const $=new Function(`return ${M.valuesConsistency}`)(),q={...M,valuesConsistency:$};return w.create(h,q)}}class R extends H{M;static type="extension";static arity=2;_index;_areSupports;_areConflicts;constructor(h,M,$,q){super(h);this._v=M;const L=$.filter((Q)=>M[0].domain.has(Q[0])&&M[1].domain.has(Q[1]));this._index=new Map;for(let Q=0;Q<L.length;Q++){const[W,Y]=L[Q];if(!this._index.has(W))this._index.set(W,new Set);this._index.get(W).add(Y)}this._areSupports=q==="supports",this._areConflicts=q==="conflicts"}get type(){return R.type}get arity(){return R.arity}get variableNames(){return[this._v[0].name,this._v[1].name]}checkConsistency(){const[h,M]=this._v;if(!(h.isSet()&&M.isSet()))return!1;const $=this._index.get(h.value);return $&&$.has(M.value)?this._areSupports:this._areConflicts}toJSON(){const h=[];for(let M of this._index.keys())for(let $ of this._index.get(M).values())h.push([M,$]);return{type:R.type,arity:R.arity,variables:this.variableNames,tuples:h,tuplesType:this._areSupports?"supports":"conflicts"}}static create(h,M){const[$,q]=M.variables,L=F($),Q=F(q);if(!(L&&Q))throw new Error(`The constraint "${h}" refers to the variables "${$}" and "${q}" but one of them is unknown`);const W=new R(h,[L,Q],M.tuples,M.tuplesType);return H.constraints.set(h,W),W}static fromJSON(h,M){return R.create(h,M)}}function i(h){return h.type===w.type}function e(h){return h.type===w.type}function v(h,M){return i(M)?w.fromJSON(h,M):R.fromJSON(h,M)}function u(h,M){return e(M)?w.create(h,M):R.create(h,M)}function a(h){return h.arity===N}function n(h){return h.arity===N}function p(h,M){return a(M)?d(h,M):v(h,M)}function f(h,M){return n(M)?j(h,M):u(h,M)}class z{h;M;$;q;_solutionSpaceSize;constructor(h,M,$,q){this._name=h;this._domains=M;this._variables=$;this._constraints=q;this._solutionSpaceSize=this.computeSolutionSpaceSize()}get name(){return this._name}get solutionsSpaceSize(){return this._solutionSpaceSize}get domains(){return this._domains}get variables(){return this._variables}get constraints(){return this._constraints}static bigintRatio(h,M){const $=this.simplifyFraction(h,M);return $[0]<=Number.MAX_SAFE_INTEGER&&$[1]<=Number.MAX_SAFE_INTEGER?Number($[0])/Number($[1]):$}computeSolutionSpaceSize(){let h=1n,M=0n;for(let $ of this._variables.values())M=h*BigInt($.domain.getSize()),h=M;return M}static pgcd(h,M){if(h===0n||M===0n)return 1n;const $=h>M?h:M,q=h<=M?h:M,L=$/q,Q=$%q;return Q===0n?L:this.pgcd(L,Q)}static simplifyFraction(h,M){let $=h,q=M,L=this.pgcd($,q);while(L>1n)$=$/L,q=q/L,L=this.pgcd($,q);return[$,q]}toJSON(){const h={};for(let[q,L]of this._domains.entries())h[q]=L.toJSON();const M={};for(let[q,L]of this._variables.entries())M[q]=L.toJSON();const $={};for(let[q,L]of this._constraints.entries())$[q]=L.toJSON();return{name:this._name,domains:h,variables:M,constraints:$}}setAffectation(h){for(let M in h){const $=this._variables.get(M),q=h[M];if($?.domain.has(q))$.set(q)}}unsetAffectation(h){for(let M in h){const $=this._variables.get(M);if($?.isSet())$.unset()}}static propsToDomains(h){const M=new Map;for(let $ in h.domains)M.set($,E($,h.domains[$]));return M}static propsToVariables(h){const M=new Map;for(let $ in h.variables)M.set($,P($,h.variables[$]));return M}static propsToConstraints(h){const M=new Map;for(let $ in h.constraints)M.set($,p($,h.constraints[$]));return M}static fromJSON(h){return new z(h.name,z.propsToDomains(h),z.propsToVariables(h),z.propsToConstraints(h))}}class D{h;_workingProblem;_solving=!1;constructor(h){this._initialProblem=h}get solving(){return this._solving}copyProblem(h){const M=h.toJSON();return z.fromJSON(M)}*_gtAffectation(){const h=[];for(let L of this._workingProblem.variables.keys())h.push(L);const M=[];for(let L of h){const W=this._workingProblem.variables.get(L).domain.toJSON();if(W.length===0)return;M.push([L,0,W])}const $=M.reduce((L,[Q,W,Y])=>L+Y.length,0);let q=0;while(q<$&&this._solving){const L={};for(let[Q,W,Y]of M)L[Q]=Y[W];yield L,q=0;for(let Q=M.length-1;Q>=0;Q--){const[W,Y,Z]=M[Q];if(Y<Z.length-1){M[Q][1]++,q+=M[Q][1];break}else M[Q][1]=0}}}*gt(h=!0,M=!1){this._solving=!0,this._workingProblem=this.copyProblem(this._initialProblem);for(let $ of this._gtAffectation()){if(!this._solving)return;const q=this._gtIsConsistent($);if(q||M)yield[$,q];if(q&&h)return}}_gtIsConsistent(h){if(!this._workingProblem)return!1;this._workingProblem.setAffectation(h);for(let M of this._workingProblem.constraints.values())if(!M.checkConsistency())return!1;return this._workingProblem.unsetAffectation(h),!0}stop(){this._solving=!1}static create(h){return new D(h.problem)}}class K extends z{L;static baseCellDomain=E("baseCellDomain",[1,2,3,4,5,6,7,8,9]);static mustBeDifferent=(h,M)=>h!==M;constructor(h,M,$,q,L){super(h,M,$,q);this._ui=L}static prepareDomains(){const h=new Map,M=[];for(let $=0;$<9;$++){const q=[];for(let L=0;L<9;L++){const Q=`d:${L}x${$}`,W=K.baseCellDomain.copy(Q);h.set(Q,W),q.push(Q)}M.push(q)}return[h,M]}static vName(h,M){return`cell${h}x${M}`}static prepareVariables(h){const M=[],$=new Map;for(let q=0;q<9;q++){const L=[];for(let Q=0;Q<9;Q++){const W=h[q][Q],Y=K.vName(Q,q),Z=P(Y,{domain:W});$.set(Y,Z),L.push(Y)}M.push(L)}return[$,M]}static rule(h,M){return{type:"intension",arity:2,variables:[h,M],valuesConsistency:K.mustBeDifferent}}static prepareConstraints(h){const M=new Map;for(let $=0;$<9;$++)for(let q=0;q<9;q++)for(let L=q+1;L<9;L++){let Q=`c:${q}x${$}->${L}x${$}`,W=K.rule(h[$][q],h[$][L]),Y=f(Q,W);M.set(Q,Y),Q=`c:${$}x${q}->${$}x${L}`,W=K.rule(h[q][$],h[L][$]),Y=f(Q,W),M.set(Q,Y)}for(let $=0;$<9;$++){const q=$%3,L=($-q)/3%3;for(let Q=0;Q<9;Q++){const W=Q%3,Y=q+W,Z=(Q-W)/3%3,T=L+Z;for(let A=Q;A<9;A++){const g=A%3,x=q+g,k=(A-g)/3%3,U=L+k,I=`c:${Y}x${T}->${x}x${U}`,l=K.rule(h[T][Y],h[U][x]),r=f(I,l);M.set(I,r)}}}return M}static create(h){const[M,$]=K.prepareDomains(),[q,L]=K.prepareVariables($),Q=K.prepareConstraints(L);return new K(h.name,M,q,Q,h.ui)}_getVariable(h,M){const $=K.vName(h,M);return this._variables.get($)}_drawCellContent(h,M){const $=this._getVariable(h,M);if($)if($.isSet())this._ui.drawCellValue(h,M,$.value);else this._ui.drawCellDomain(h,M,$.domain)}cellIsSet(h,M){return this._getVariable(h,M)?.isSet()??!1}domainHas(h,M,$){return this._getVariable(h,M)?.domain.has($)??!1}drawCellsContent(){for(let h=0;h<9;h++)for(let M=0;M<9;M++)this._drawCellContent(M,h)}setCellValue(h,M,$){this._getVariable(h,M)?.set($)}unsetCellValue(h,M){this._getVariable(h,M)?.unset()}getCellValue(h,M){return this._getVariable(h,M)?.value}_removeValue(h,M,$){this._getVariable(h,M)?.domain.del($)}_addValue(h,M,$){this._getVariable(h,M)?.domain.add($)}maintainImpactedCellsDomain(h,M,$,q){const L=q?this._removeValue.bind(this):this._addValue.bind(this);for(let Y=0;Y<9;Y++){if(Y!==h)L&&L(Y,M,$);if(Y!==M)L&&L(h,Y,$)}const Q=Math.floor(h/3),W=Math.floor(M/3);for(let Y=0;Y<3;Y++)for(let Z=0;Z<3;Z++){const T=Q*3+Z,A=W*3+Y;if(T!==h&&A!==M)L&&L(T,A,$)}}}class y{h;M;selectedCell=null;_problem;_statsDisplay;_solver;_iterationsMin=0;_iterationsMax=0;_lastTime=0;_startTime=0;_minDt=Number.MAX_SAFE_INTEGER;_handleRefreshStats=null;_solverSteps;_testedSolutions=0n;_prunedSolutions=0n;_gtIterator=null;constructor(h,M){this._ui=h;this._elements=M}get solutionSpaceSize(){return this._problem?.solutionsSpaceSize}get stats(){return{start:this._startTime,tested:this._testedSolutions,pruned:this._prunedSolutions}}_refreshGrid(){this._ui.drawEmptyGrid().colorizeSelectedStuff(this.selectedCell),this._problem?.drawCellsContent()}_toggle(h){if(!this._problem)return;const[M,$]=this.selectedCell;if(!this._problem.cellIsSet(M,$)){if(this._problem?.domainHas(M,$,h)??!1)this._problem?.setCellValue(M,$,h),this._problem?.maintainImpactedCellsDomain(M,$,h,!0),this._refreshGrid()}else if(this._problem?.getCellValue(M,$)===h){this._problem?.unsetCellValue(M,$),this._problem?.maintainImpactedCellsDomain(M,$,h,!1);for(let q=0;q<9;q++)for(let L=0;L<9;L++)if(this._problem?.getCellValue(L,q)===h)this._problem?.maintainImpactedCellsDomain(L,q,h,!0);this._refreshGrid()}}start(){if(S({app:this,elements:this._elements,ui:this._ui,refreshGrid:this._refreshGrid.bind(this),toggle:this._toggle.bind(this),getSelectedCell:()=>this.selectedCell,setSelectedCell:(h)=>this.selectedCell=h}),this._problem=K.create({name:`sudoku-${Date.now()}`,ui:this._ui}),this._refreshGrid(),!this._solver)this._solver=D.create({problem:this._problem});if(typeof this._statsDisplay==="undefined")this._statsDisplay=_.create({app:this,solutionSpaceSizeP:this._elements.solutionSpaceSizeP,testedSolutionsP:this._elements.testedSolutionsP,prunedSolutionsP:this._elements.prunedSolutionsP,progressP:this._elements.progressP,timeleftP:this._elements.timeleftP});this._statsDisplay.display()}stop(){if(this._solver?.stop(),this._gtIterator=null,this._lastTime=0,this._solverSteps=void 0,C(this._elements),this._elements.ncCheckbox.checked=!1,this._elements.acNoneRadio.checked=!0,this._handleRefreshStats!==null)clearInterval(this._handleRefreshStats),this._handleRefreshStats=null}reset(){this.stop(),this.start()}_computeSolvingIterations(h){const M=h-this._lastTime;if(M*0.9<=this._minDt/2)this._iterationsMax*=2,this._iterationsMin*=2;else if(M*0.9<=this._minDt)this._iterationsMin=Math.floor(this._iterationsMin*1.5),this._iterationsMax=Math.max(this._iterationsMin+1,this._iterationsMax);else if(M*1.1>=this._minDt*2)this._iterationsMin=Math.max(Math.floor(this._iterationsMin/2),1),this._iterationsMax=Math.max(Math.floor(this._iterationsMax/2),2);else if(M*1.1>=this._minDt)this._iterationsMax=Math.ceil(this._iterationsMax*0.67),this._iterationsMin=Math.min(this._iterationsMax-1,this._iterationsMin);return this._minDt=Math.min(this._minDt,M),this._lastTime=h,Math.max(Math.floor((this._iterationsMax+this._iterationsMin)/2),1)}launchGTSolve(){if(!this._solver||this._solver.solving||!this._problem)return;if(this._startTime=Date.now(),this._testedSolutions=0n,this._prunedSolutions=0n,this._minDt=Number.MAX_SAFE_INTEGER,this._iterationsMin=1,this._iterationsMax=1000,this._handleRefreshStats===null)this._handleRefreshStats=setInterval(()=>{this._statsDisplay?.display()},500);if(this._solverSteps=(h)=>{let M=null;for(let $=0;$<h;$++){const[q,L]=this._gtIterator.next().value;if(M=q,this._testedSolutions++,L){this._gtIterator=null;break}}if(M)this._problem.setAffectation(M)},this._gtIterator===null)this._gtIterator=this._solver.gt(!0,!0);this._animateSolve(1000)}_animateSolve(h){if(this._solverSteps){if(this._solverSteps(this._computeSolvingIterations(h)),this._refreshGrid(),this._solver?.solving)requestAnimationFrame(this._animateSolve.bind(this))}}static create(h){const M=b(h);if(M===null)return null;const $=X.get(M.canvas);if(!$)return null;return new y($,M)}}var hh="sudokuCanvas",Mh="solutionsSpaceSize",$h="reset",qh="GT",Lh="BT",Qh="NC",Wh="ACNone",Yh="AC1",Xh="AC3",Zh="testedSolutions",Hh="prunedSolutions",Kh="progress",Gh="timeleft";B();var m=y.create({canvasId:hh,solutionSpaceSizePId:Mh,resetBtnId:$h,gtBtnId:qh,btBtnId:Lh,ncCheckboxId:Qh,acNoneRadioId:Wh,ac1RadioId:Yh,ac3RadioId:Xh,testedSolutionsPId:Zh,prunedSolutionsPId:Hh,progressPId:Kh,timeleftPId:Gh});m&&m.start();
